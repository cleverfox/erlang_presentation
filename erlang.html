<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=1024, user-scalable=no">

  <title>Your deck.js Presentation</title>

  <!-- Required stylesheet -->
  <link rel="stylesheet" media="screen" href="../deck.js/core/deck.core.css">

  <!-- Extension CSS files go here. Remove or add as needed. -->
  <link rel="stylesheet" media="screen" href="../deck.js/extensions/goto/deck.goto.css">
  <link rel="stylesheet" media="screen" href="../deck.js/extensions/menu/deck.menu.css">
  <link rel="stylesheet" media="screen" href="../deck.js/extensions/navigation/deck.navigation.css">
  <link rel="stylesheet" media="screen" href="../deck.js/extensions/status/deck.status.css">
  <link rel="stylesheet" media="screen" href="../deck.js/extensions/scale/deck.scale.css">

  <!-- Style theme. More available in /themes/style/ or create your own. -->
  <link rel="stylesheet" media="screen" href="../deck.js/themes/style/web-2.0.css">

  <!-- Transition theme. More available in /themes/transition/ or create your own. -->
  <link rel="stylesheet" media="screen" href="../deck.js/themes/transition/horizontal-slide.css">

  <!-- Basic black and white print styles -->
  <link rel="stylesheet" media="print" href="../deck.js/core/print.css">

  <!-- Required Modernizr file -->
  <script src="../deck.js/modernizr.custom.js"></script>
</head>
<body>
  <div class="deck-container">
<style>
p,ul {
font-size: 1.6em;
}
ol{
list-style-type: square;
}
</style>
    <!-- Begin slides. Just make elements with a class of slide. -->

    <section class="slide">
      <h1>Erlang? Нет, не слыхали...</h1>
    </section>
    <section class="slide">
      <h2>Erlang? Нет, не слыхали...</h2>
		<div>
		Компании Ericsson нужен был язык программирования, который подошел бы им для разработки сложного ПО для маршрутизаторов и ATM коммутаторов
		</div>
		<div class="slide">
		Поиском занимались:
		<ul>
		<li>Джо Армстронг (Joe Armstrong)</li>
		<li>Роберт Вирдинг (Robert Virding)</li>
		<li>Майк Вильямс (Mike Williams)</li>
		<li>под руководством Бьярне Деккера (Bjarne Däcker)</li>
		</ul>
		</div>
    </section>
    <section class="slide">
      <h2>Erlang? Нет, не слыхали...</h2>
	  <h1>Они искали...</h1>
    </section>
    <section class="slide">
      <h2>Erlang? Нет, не слыхали...</h2>
	  <h1>Они долго искали........</h1>
    </section>
    <section class="slide">
      <h2>Erlang? Нет, не слыхали...</h2>
	  <h1>Но.... не нашли :)</h1>
    </section>
    <section class="slide">
	<img src="logo.png">
	<p>Зародился в 1987 году</p>
	<ul>
		<li  class="slide">
		Влияние на Erlang оказали ML, Миранда, Ада, Модула-2, CHILL, Пролог. Кроме того, на способ обновления программного обеспечения повлиял Smalltalk и использованные Ericsson проприетарные языки EriPascal и PLEX
		</li>
		<li  class="slide">
		В течении 4х лет протопитировался на вирутальной машине Пролога, затем в 1991 году вирутуальная машина Erlang была написана на Си
		</li>
		<li  class="slide">
		Впервые в коммерческом продукте применен в 1992 году.
		</li>
		<li  class="slide">
		В OpenSource отдали в 1998 году.
		</li>
	</ul>
    </section>

    <section class="slide">
	<img src="logo.png">
		<p>
		Назван в честь датского математика и инженера Агнера Эрланга, основателя научного направления по изучению сетевого трафика в телекоммуникационных системах
		</p>
      <h2 class="slide">Но мы-то все понимаем, что на самом деле это Er<strike style="font-weight:normal">icsson</strike> lang<strike style="font-weight:normal">uage</strike> :-))</h2>
    </section>

    <section class="slide">
      <h2>В каком языке нуждалась Ericsson?</h2>
		<p>
		По свидетельству Майка Вильямса, Erlang задумывался для решения трёх проблем разработки распределённых 
		систем мягкого реального времени с высокой степенью параллелизма: 
		<ul>
		<li>возможности быстрой и эффективной разработки ПО</li>
		<li>получения системы, устойчивой к программным и аппаратным сбоям и возможности обновления системы «на лету», без простоя оборудования</li>
</ul>
</p>
<p>
Большинство языков, созданных прежде Erlang, были разработаны без предварительного нахождения своей области применения, 
тогда как Erlang был разработан специально на основе требований к распределённым, отказоустойчивым, параллельным системам 
реального времени. 
</p>
    </section>

    <section class="slide">
      <h1>Какой язык получился?</h1>
	</section>
 
    <section class="slide">
      <h2>Какой язык получился?</h2>
		<h3>Функциональный</h3>
			<p class="whitebg">
				Не далее как 2 недели назад мы уже кое что узнали о функциональных языках, повторять не будем :)
			</p>		
	</section>

    <section class="slide">
      <h2>Какой язык получился?</h2>
		<h3>Высокоуровневые конструкции</h3>
			<ul>
<li>Элементы декларативного языка программирования:
<div style="font-size: 0.8em">
Например, определение функции, которое использует сопоставление с образцом (pattern matching) для выбора одного 
из вариантов вычисления или извлечения элемента данных из составной структуры, напоминает уравнение. 
<br>
Сопоставление с образцом распространено даже на битовые строки, что упрощает реализацию телекоммуникационных протоколов.
</div>
</li>
<li>
Функции являются объектами первого класса в Erlang. 
</li>
<li>
В языке также широко применяются характерные для функциональной 
парадигмы программирования списковые включения (List Comprehensions).
</li>
</ul>		
	</section>
			
    <section class="slide">
      <h2>Какой язык получился?</h2>
		<h3>Параллельные вычисления</h3>
			<p>
				В виртуальной машине Erlang применяются легкие процессы (процессы не ОС, а виртуальной машины).
			<br>
			Память таких процессов изолирована друг от друга, нет способа "залезть" в память другого процесса и там что-то испортить.
			<br>
			В случае, если "что-то пошло не так", процесс завершается не "роняет" другой процесс (если этого не требуется).
			<br>
			Процессы взаимодействуют между собой путем обмена сообщениями.	
			</p>		
	</section>
		
    <section class="slide">
      <h2>Какой язык получился?</h2>
		<h3>Распределённые вычисления</h3>
			<p>
			Процессы могут располагаться на разных нодах (в том числе на разных физических машинах), при этом работа с ними осуществляется так же как с "местными" процессами.
			В erlang это называется distribution.
			</p>		
	</section>
	
    <section class="slide">
      <h2>Какой язык получился?</h2>
		<h3>Мягкое реальное время</h3>
			<p>
			Программы на высокоуровневом языке Erlang могут быть использованы в системах мягкого реального времени. <br>
			Поскольку управление памятью и сборка мусора происходит в каждом проессе отдельно и независимо от других процессов, 
			сборка мусора занимает короткий интервал времени, и не вызывает "фризов", в отличии от других языков с автоматической
			сборкой мусора.
			<br>
			Это дает возможность создавать системы с очень маленьким временем отклика (единицы миллисекунд), не испытывающие 
			ухудшения пропускной способности с ростом нагрузки.
			</p>		
	</section>
		
			
    <section class="slide">
      <h2>Какой язык получился?</h2>
	  <h3>Горячая замена кода</h3>
			<p>
			В Erlang замена кода сделана просто и гениально: <br>
			2 экземплара кода (текущий и новый) для каждого модуля. 
			</p>
			<p class="slide">Смена версии возникает при вызове функции.</p>
			<p class="slide">Менять можно каждый модуль отдельно.</p>
			<p class="slide">Смена версии, как правило, не приводит к каким-либо задержкам в выполнении программы.</p>
			<p class="slide">При использовании механизма релизов можно апгрейдить/даунгрейдить состояние процесса.
			</p>
    </section>


    <section class="slide">
      <h2>Какой язык получился?</h2>
	  <h3>Отказоустойчивость</h3>
<p>
Высокая отказоустойчивость кроется в применении изолированных друг от друга облегчённых процессов, 
связанных лишь механизмом обмена сообщениями и сигналами выхода. 
Принцип разработчиков на Erlang по отношению к обработке ошибочных ситуаций в процессах можно выразить в виде высказывания:
<u>
«Позвольте процессу упасть, и пускай кто-то другой займётся им»
</u>
<br>
или сокращённо — «let it crash» («пусть падает»). 
</p>
<p>
Связано это с тем, что в Erlang-системе легко следить за завершением процесса, завершать процессы, связанные со сбойным, и запускать новые процессы.
</p>
    </section>

    <section class="slide">
      <h1>Какой он для программиста?</h1>
    </section>

    <section class="slide">
      <h2>Какой он для программиста?</h2>
      <p class="slide">Программа компилируется в байт-код;</p>
      <p class="slide">Байт-код выполняется внутри вируальной машины BEAM;</p>
      <p class="slide">Легковесные процессы виртуальной машины;</p>
      <p class="slide">Процессы обмениваются сообщениями;</p>
      <p class="slide">Shared memory нет;</p>
      <p class="slide">Ну почти нет. Для крайних случаев есть ETS. :)</p>
    </section>

    <section class="slide">
      <h1>Типы данных в Erlang</h1>
    </section>

    <section class="slide">
      <h2>Типы данных в Erlang</h2>
      <ul>
		<li>integer/float
		<li>atom
		<li>function
		<li>list
		<li>tuple
		<li>binary
		<li>map
		<li>pid/port/reference
		<li>логические типы. Атомы true и false.
		</ul>
      <h3>Типизация динамическая, строгая.</h3>
    </section>

    <section class="slide">
      <h2>Типы данных в Erlang</h2>
		<p>integer/float
		<pre class="hideme">
1> A=10.
10
2> is_integer(A).
true
3> is_float(A).
false
4> PI=3.141592653589793238462643383279.
3.141592653589793
5> is_integer(PI).
false
6> is_float(PI).
true
7> SUM=A+PI.
13.141592653589793
8> is_float(SUM).
true	</pre></p>
    </section>

    <section class="slide">
      <h2>Типы данных в Erlang</h2>

		<p>atom
		<pre class="hideme">
1> is_atom(a).
true
2> a.
a
3> a==b.
false
4> a==a.
true
5> atom1.
atom1
6> atom2=atom1.
false </pre></p>
    </section>

    <section class="slide">
      <h2>Типы данных в Erlang</h2>
		<p>function
		<pre class="hideme">
1> MyF=fun(X,Y) -> X+Y end.
#Fun<erl_eval.12.90072148>
2> is_function(MyF).
true
3> MyF(10,2).
12
4> MyF2=fun(X,Y,Z) -> X+Y*Z end.
#Fun<erl_eval.18.90072148>
5> MyF2(10,2).
** exception error: interpreted function with arity 3 called with two arguments
6> MyF2(10,2,3).
16</pre></p>
    </section>

    <section class="slide">
      <h2>Типы данных в Erlang</h2>
		<p>list
		<pre>
1> L=[1,2,3,a,b,c].
[1,2,3,a,b,c]
2> is_list(L).
true
3> [1,2,3,a,b,c]++[d,e,f].
[1,2,3,a,b,c,d,e,f]
4> [1,2,3,a,b,c]--[1,3,c].
[2,a,b]</pre></p>
    </section>

    <section class="slide">
      <h2>Типы данных в Erlang</h2>
		<p>tuple
		<pre>
1> Point={51.11,36.12}.
{51.11,36.12}
2> Point.
{51.11,36.12}
3> is_tuple(Point).
true
4> {Lat,Lon}=Point.
{51.11,36.12}
5> Lon.
36.12
6> Lat.
51.11
7> Point3D={10,21,3}.
{10,21,3}
8> {X,Y,Z}=Point3D.
{10,21,3}
9> X.
10
10> Y.
21
11> Z.
3</pre></p>
    </section>

    <section class="slide">
      <h2>Типы данных в Erlang</h2>
		<p>binary
		<pre class="hideme">
1> Bin1 = &lt;&lt;1,2,3>>. 
&lt;&lt;1,2,3>>
2> Bin2 = &lt;&lt;4,5>>. 
&lt;&lt;4,5>>
3> Bin3 = &lt;&lt;6>>.
&lt;&lt;6>>
4> list_to_binary([Bin1,1,[2,3,Bin2],4|Bin3]). 
&lt;&lt;1,2,3,1,2,3,4,5,4,6>>
5> Hex=16#2423.
9251
6> &lt;&lt;Hex:16/integer,Hex:16/little>>.
&lt;&lt;"$##$">>
7> binary_to_list(&lt;&lt;Hex:16/integer,Hex:16/little>>).
"$##$"</pre></p>
    </section>

    <section class="slide">
      <h2>Типы данных в Erlang</h2>
		<p>map
		<pre>
1> #{a=>123,b=>234}.
#{a => 123,b => 234}
2> HexMap= #{0=>0,1=>1,2=>2,3=>3,4=>4,5=>5,6=>6,7=>7,8=>8,9=>9,a=>10,b=>11,c=>12,d=>13,e=>14,f=>15}.
#{0 => 0,1 => 1,2 => 2,3 => 3,4 => 4,5 => 5,6 => 6,7 => 7,8 => 8,9 => 9,a => 10,b => 11,c => 12,d => 13,e => 14,f => 15}
3> maps:get(3,HexMap).
3
4> maps:get(b,HexMap).
11</pre>
		</p>
    </section>

    <section class="slide">
      <h2>Типы данных в Erlang</h2>		
		<p>pid/port/reference
		<pre class="hideme">
1> self().
<0.32.0>
2> gen_tcp:listen(12345,[]).
{ok,#Port<0.579>}
3> erlang:send_after(1000,self(),preved).
#Ref<0.0.0.38></pre></p>
    </section>

    <section class="slide">
      <h2>Типы данных в Erlang</h2>
		<p>логические типы. Атомы true и false.
		<pre class="hideme">
1> true or false.
true
2> true and false.
false
3> true xor false.
true
4> not false.
true
5> (not (true xor true)) or (false and true).
true</pre></p>
    </section>


    <section class="slide">
      <h3>Про что надо сказать</h3>
      <ul>
      <li>Pattern matching</li>
      <li>Arity</li>
      <li>List comprehensions</li>
      <li>Память</li>
      </ul>
    </section>
  
    
    
    
<style>
pre {
	font-size: 0.8em;
}
.deck-current .hideme {
	display:block;
}
.hideme {
	display:none;
}
.whitebg {
	background: rgba(255,255,255,0.9);
	padding: 5px;
	border-radius: 10px;
}
</style>

    <!-- End slides. -->

    <!-- Begin extension snippets. Add or remove as needed. -->

    <!-- deck.navigation snippet -->
    <!--div aria-role="navigation">
      <a href="#" class="deck-prev-link" title="Previous">&#8592;</a>
      <a href="#" class="deck-next-link" title="Next">&#8594;</a>
    </div-->

    <!-- deck.status snippet -->
    <!--p class="deck-status" aria-role="status">
      <span class="deck-status-current"></span>
      /
      <span class="deck-status-total"></span>
    </p-->

    <!-- deck.goto snippet -->
    <form action="." method="get" class="goto-form">
      <label for="goto-slide">Go to slide:</label>
      <input type="text" name="slidenum" id="goto-slide" list="goto-datalist">
      <datalist id="goto-datalist"></datalist>
      <input type="submit" value="Go">
    </form>

    <!-- End extension snippets. -->
  </div>

<!-- Required JS files. -->
<script src="../deck.js/jquery.min.js"></script>
<script src="../deck.js/core/deck.core.js"></script>

<!-- Extension JS files. Add or remove as needed. -->
<script src="../deck.js/extensions/menu/deck.menu.js"></script>
<script src="../deck.js/extensions/goto/deck.goto.js"></script>
<script src="../deck.js/extensions/status/deck.status.js"></script>
<script src="../deck.js/extensions/navigation/deck.navigation.js"></script>
<script src="../deck.js/extensions/scale/deck.scale.js"></script>

<!-- Initialize the deck. You can put this in an external file if desired. -->
<script>
  $(function() {
    $.deck('.slide');
  });
</script>
</body>
</html>
